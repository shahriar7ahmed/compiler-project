#include "compiler/vm/VirtualMachine.h"
#include "compiler/codegen/CodeGenerator.h"
#include "compiler/optimizer/Optimizer.h"
#include "compiler/semantic/SemanticAnalyzer.h"
#include "compiler/parser/Parser.h"
#include "compiler/lexer/Lexer.h"
#include <iostream>

void testFullPipeline(const std::string& testName, const std::string& source, 
                      bool optimize = false, bool trace = false) {
    std::cout << "════════════════════════════════════════\n";
    std::cout << "Test: " << testName << "\n";
    std::cout << "════════════════════════════════════════\n";
    std::cout << "Source:\n" << source << "\n\n";
    
    try {
        // Full compilation pipeline
        Lexer lexer(source);
        auto tokens = lexer.getAllTokens();
        
        Parser parser(tokens);
        auto program = parser.parse();
        
        SemanticAnalyzer analyzer(program);
        analyzer.analyze();
        
        if (analyzer.hasErrors()) {
            std::cout << "❌ Semantic errors:\n";
            for (const auto& error : analyzer.getErrors()) {
                std::cout << "  • " << error.what() << "\n";
            }
            return;
        }
        
        if (optimize) {
            Optimizer optimizer;
            optimizer.optimize(program);
            std::cout << "Optimizations applied: " << optimizer.getOptimizationCount() << "\n\n";
        }
        
        CodeGenerator codegen;
        BytecodeProgram bytecode = codegen.generate(program);
        
        std::cout << "Generated Bytecode:\n";
        bytecode.print();
        std::cout << "\n";
        
        // Execute
        VirtualMachine vm;
        vm.setTraceMode(trace);
        
        std::cout << "Program Output:\n";
        std::cout << "──────────────────────────────────\n";
        vm.execute(bytecode);
        std::cout << "──────────────────────────────────\n";
        
        if (!trace) {
            std::cout << "Instructions executed: " << vm.getInstructionCount() << "\n";
        }
        
        std::cout << "✅ Execution successful!\n";
        
    } catch (const std::exception& e) {
        std::cout << "❌ Error: " << e.what() << "\n";
    }
    
    std::cout << "\n";
}

int main() {
    std::cout << "╔════════════════════════════════════════════╗\n";
    std::cout << "║  Educational Compiler - Full Pipeline     ║\n";
    std::cout << "║         VM Execution Tests                 ║\n";
    std::cout << "╚════════════════════════════════════════════╝\n\n";
    
    // Test 1: Simple execution
    testFullPipeline(
        "Simple Execution",
        "let x = 42;\n"
        "print x;"
    );
    
    // Test 2: Arithmetic
    testFullPipeline(
        "Arithmetic Operations",
        "let a = 10;\n"
        "let b = 20;\n"
        "let sum = a + b;\n"
        "print sum;"
    );
    
    // Test 3: All operations
    testFullPipeline(
        "All Arithmetic Operators",
        "print 10 + 3;\n"
        "print 10 - 3;\n"
        "print 10 * 3;\n"
        "print 10 / 3;\n"
        "print 10 % 3;"
    );
    
    // Test 4: With optimization
    testFullPipeline(
        "Optimized Execution",
        "let x = 2 + 3 * 4;\n"
        "print x;",
        true  // Enable optimization
    );
    
    // Test 5: Comparison operators
    testFullPipeline(
        "Comparison Operators",
        "print 10 > 5;\n"
        "print 3 == 3;\n"
        "print 5 < 10;\n"
        "print 7 >= 7;"
    );
    
    // Test 6: Complex expression
    testFullPipeline(
        "Complex Expression",
        "let result = (10 + 5) * (8 - 3);\n"
        "print result;"
    );
    
    // Test 7: With trace mode
    testFullPipeline(
        "Execution with Trace",
        "let x = 5;\n"
        "let y = 3;\n"
        "print x + y;",
        false,  // No optimization
        true    // Enable trace
    );
    
    // Test 8: Optimized with trace
    std::cout << "════════════════════════════════════════\n";
    std::cout << "Optimization Impact Demonstration\n";
    std::cout << "════════════════════════════════════════\n\n";
    
    std::cout << "WITHOUT Optimization:\n";
    testFullPipeline(
        "",
        "print 2 + 3 * 4;",
        false
    );
    
    std::cout << "WITH Optimization:\n";
    testFullPipeline(
        "",
        "print 2 + 3 * 4;",
        true
    );
    
    // Test 9: Multiple prints
    testFullPipeline(
        "Multiple Output Statements",
        "let a = 100;\n"
        "let b = 50;\n"
        "print a + b;\n"
        "print a - b;\n"
        "print a * b;\n"
        "print a / b;"
    );
    
    // Test 10: Nested operations
    testFullPipeline(
        "Nested Operations with Variables",
        "let x = 10;\n"
        "let y = 5;\n"
        "let z = 2;\n"
        "let result = (x + y) * z;\n"
        "print result;"
    );
    
    std::cout << "╔════════════════════════════════════════════╗\n";
    std::cout << "║          All Tests Completed!              ║\n";
    std::cout << "║                                            ║\n";
    std::cout << "║  ✅ Full Compiler Pipeline Working!        ║\n";
    std::cout << "║  Source → Bytecode → Execution → Output   ║\n";
    std::cout << "╚════════════════════════════════════════════╝\n";
    
    return 0;
}
